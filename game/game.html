<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Engine V6 - Terrain & Rocks</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.6); color: white; 
            backdrop-filter: blur(5px);
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        h1 { margin: 0; font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 4px 10px black; }
        p { font-size: 1.2rem; color: #ddd; margin-top: 10px; }
        .key { background: #333; padding: 2px 8px; border-radius: 4px; border: 1px solid #555; color: #fff; font-weight: bold; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* WEAPON SYSTEM */
        #weapon-container {
            position: absolute;
            bottom: 0; right: 25%;
            width: 0; height: 0;
            transform-origin: bottom center;
            transition: transform 0.1s linear;
        }

        /* The Image Hand */
        #hand-image {
            position: absolute;
            bottom: -50px; 
            right: -150px;
            width: 400px; 
            height: auto;
            pointer-events: none;
            /* Fallback if image missing */
            min-height: 300px;
            min-width: 200px;
            /* transform: rotate(-5deg); */
        }

        /* Punch Animation */
        @keyframes punch {
            0% { transform: translate(0, 0) rotate(0deg); }
            15% { transform: translate(-30px, -20px) rotate(-10deg) scale(1.1); }
            40% { transform: translate(60px, 40px) rotate(10deg) scale(0.9); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        .punching #hand-image {
            animation: punch 0.2s cubic-bezier(0.1, 0.7, 1.0, 0.1) forwards;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="weapon-container">
            <img id="hand-image" src="hand.png" alt="[MISSING hand.png]" draggable="false">
        </div>
    </div>

    <div id="instructions">
        <h1>High Lands V6</h1>
        <p>Click to Capture</p>
        <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move | <span class="key">SHIFT</span> Sprint | <span class="key">SPACE</span> Jump</p>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

<script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const CONFIG = {
            PLAYER_HEIGHT: 18, 
            PLAYER_RADIUS: 3.5,
            GRAVITY: 800.0,
            JUMP_FORCE: 300.0,
            WALK_SPEED: 450.0,
            SPRINT_SPEED: 900.0,
            
            TREE_COUNT: 600,     
            ROCK_COUNT: 150,     
            WORLD_SIZE: 10000,   
            BOB_SPEED: 12
        };

        // --- Globals ---
        let camera, scene, renderer, controls;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let isSprinting = false;

        let prevTime = performance.now();
        let bobTimer = 0;
        
        // Physics
        const collidableObjects = []; 
        const playerBox = new THREE.Box3();
        const tempBox = new THREE.Box3();

        init();
        animate();

        function init() {
            // 1. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 2. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x8cb6c9, 0.0015);

            // 3. Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.rotation.order = 'YXZ';

            controls = new PointerLockControls(camera, document.body);
            
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => controls.lock());
            
            controls.addEventListener('lock', () => { instructions.style.opacity = '0'; setTimeout(()=> instructions.style.display = 'none', 300); });
            controls.addEventListener('unlock', () => { instructions.style.display = 'flex'; setTimeout(()=> instructions.style.opacity = '1', 10); });

            // Initial Position
            const startY = getTerrainHeight(0, 0) + CONFIG.PLAYER_HEIGHT;
            controls.getObject().position.set(0, startY, 0);
            scene.add(controls.getObject());

            // 4. Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            const sun = new THREE.DirectionalLight(0xffeebb, 1.5);
            sun.position.set(150, 300, 100);
            sun.castShadow = true;
            sun.shadow.mapSize.set(4096, 4096);
            sun.shadow.camera.left = -2000; sun.shadow.camera.right = 2000;
            sun.shadow.camera.top = 2000; sun.shadow.camera.bottom = -2000;
            scene.add(sun);

            // 5. World Generation
            generateTerrain(); 
            generateRocks();
            generateTrees();   
            generateCabin();   // Updated detailed cabin

            // 6. Listeners
            setupInputs();
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', performPunch);
        }

        function setupInputs() {
            const onKeyDown = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'ShiftLeft': isSprinting = true; break;
                    case 'Space': if (canJump) { velocity.y += CONFIG.JUMP_FORCE; canJump = false; } break;
                }
            };
            const onKeyUp = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isSprinting = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        function getTerrainHeight(x, z) {
            // Large rolling hills
            const huge = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 80;
            const valley = Math.sin(x * 0.005 + 2) * Math.cos(z * 0.005) * 20;
            const small = Math.sin(x * 0.03) * Math.cos(z * 0.03 + 2) * 2;
            return Math.max(-100, huge + valley + small);
        }

        // --- WORLD GENERATION ---

        function generateTerrain() {
            // 1. Procedural Canvas Texture
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#3a4f15'; 
            ctx.fillRect(0,0,512,512);

            // Grass noise
            for(let i=0; i<15000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#4b6b1f' : '#28380e';
                ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(100, 100); 
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            tex.anisotropy = 16;

            const mat = new THREE.MeshStandardMaterial({ 
                map: tex, 
                roughness: 0.9, 
                color: 0xaaaaaa 
            });

            // 2. Geometry
            const segments = 128; 
            const geo = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE, segments, segments);
            const posAttribute = geo.attributes.position;
            const vertex = new THREE.Vector3();

            for (let i = 0; i < posAttribute.count; i++) {
                vertex.fromBufferAttribute(posAttribute, i);
                const h = getTerrainHeight(vertex.x, vertex.y);
                posAttribute.setZ(i, h);
            }

            geo.computeVertexNormals();

            const terrain = new THREE.Mesh(geo, mat);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        function generateCabin() {
            const cabinX = 80;
            const cabinZ = -60;
            const groundH = getTerrainHeight(cabinX, cabinZ);

            // Larger Dimensions for interior
            const W = 90; // Width (X axis)
            const D = 70; // Depth (Z axis)
            const H = 45; // Wall Height
            const THICK = 3; // Wall thickness

            const group = new THREE.Group();
            group.position.set(cabinX, groundH, cabinZ);

            // Materials
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9, name: 'wood' });
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x4d3326, roughness: 1.0, name: 'floor' });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x362312, roughness: 1.0, name: 'roof' });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.3, roughness: 0.1, metalness: 0.8, name: 'glass' });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a1a10, roughness: 0.8, name: 'frame' });

            // Helper to create parts and physics simultaneously
            function createPart(geo, mat, x, y, z, isPhysics = true) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);

                if (isPhysics) {
                    // Create collision box in world space
                    const worldPos = new THREE.Vector3(cabinX + x, groundH + y, cabinZ + z);
                    geo.computeBoundingBox();
                    const size = new THREE.Vector3();
                    geo.boundingBox.getSize(size);
                    
                    const boundary = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z));
                    boundary.position.copy(worldPos);
                    boundary.visible = false;
                    scene.add(boundary);
                    collidableObjects.push(boundary);
                }
                return mesh;
            }

            // 1. Floor
            createPart(new THREE.BoxGeometry(W, THICK, D), floorMat, 0, THICK/2, 0, true);

            // 2. Walls (Constructed from pieces to allow holes)
            
            // Back Wall (+Z) - Solid
            createPart(new THREE.BoxGeometry(W, H, THICK), woodMat, 0, H/2 + THICK, D/2 - THICK/2);

            // Front Wall (-Z) with Door gap
            const doorW = 25, doorH = 35;
            // Left panel
            createPart(new THREE.BoxGeometry((W-doorW)/2, H, THICK), woodMat, -(W/2 - (W-doorW)/4), H/2 + THICK, -D/2 + THICK/2);
            // Right panel
            createPart(new THREE.BoxGeometry((W-doorW)/2, H, THICK), woodMat, (W/2 - (W-doorW)/4), H/2 + THICK, -D/2 + THICK/2);
            // Top panel (above door)
            createPart(new THREE.BoxGeometry(doorW, H - doorH, THICK), woodMat, 0, doorH + (H-doorH)/2 + THICK, -D/2 + THICK/2);
        
            // Side Walls (X axes) with Window gaps
            const winW = 30, winH = 20, winY = 25; // Center Y of window

            for(const side of [-1, 1]) { // Left and Right sides
                const xPos = side * (W/2 - THICK/2);
                // Bottom panel
                createPart(new THREE.BoxGeometry(THICK, winY - winH/2, D), woodMat, xPos, (winY - winH/2)/2 + THICK, 0);
                // Top panel
                createPart(new THREE.BoxGeometry(THICK, H - (winY + winH/2), D), woodMat, xPos, (winY + winH/2) + (H - (winY + winH/2))/2 + THICK, 0);
                // Side pillars around window
                const pillarD = (D - winW) / 2;
                createPart(new THREE.BoxGeometry(THICK, winH, pillarD), woodMat, xPos, winY + THICK, -D/2 + pillarD/2);
                createPart(new THREE.BoxGeometry(THICK, winH, pillarD), woodMat, xPos, winY + THICK, D/2 - pillarD/2);

                // Window Glass & Frame
                createPart(new THREE.BoxGeometry(THICK/2, winH, winW), glassMat, xPos, winY + THICK, 0, false);
                createPart(new THREE.BoxGeometry(THICK+1, winH + 2, winW + 2), frameMat, xPos, winY + THICK, 0, false);
            }

            // 3. Roof (Large 4-sided cone resting on top)
            const roofHeight = 25;
            // Scale cone to fit square base roughly
            const roofScale = Math.sqrt((W*W)/2) + 10; 
            const roof = new THREE.Mesh(new THREE.ConeGeometry(1, 1, 4), roofMat);
            roof.position.set(0, H + roofHeight/2 + THICK, 0);
            roof.rotation.y = Math.PI / 4; 
            roof.scale.set(roofScale, roofHeight, roofScale);
            roof.castShadow = true;
            group.add(roof);

            scene.add(group);
        }

        function generateRocks() {
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, flatShading: true });
            const rockGeo = new THREE.DodecahedronGeometry(1, 0); 

            for(let i=0; i<CONFIG.ROCK_COUNT; i++) {
                const x = (Math.random() - 0.5) * (CONFIG.WORLD_SIZE * 0.8);
                const z = (Math.random() - 0.5) * (CONFIG.WORLD_SIZE * 0.8);

                // Increased safe zone for larger cabin
                if (Math.abs(x - 80) < 80 && Math.abs(z + 60) < 80) continue;

                const h = getTerrainHeight(x, z);
                const size = 3 + Math.random() * 8;
                
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(x, h + (size*0.2), z);
                rock.scale.set(size, size * 0.8, size);
                rock.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                rock.castShadow = true;
                rock.receiveShadow = true;

                // Physics
                const boundary = new THREE.Mesh(new THREE.BoxGeometry(size*1.5, size*2, size*1.5));
                boundary.position.copy(rock.position);
                boundary.visible = false;
                scene.add(boundary);
                collidableObjects.push(boundary);

                scene.add(rock);
            }
        }

        function generateTrees() {
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 1.0 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8 });
            const geomTrunk = new THREE.CylinderGeometry(1, 1.5, 1, 6);
            const geomCone = new THREE.ConeGeometry(1, 1, 6);

            for (let i = 0; i < CONFIG.TREE_COUNT; i++) {
                const x = (Math.random() - 0.5) * (CONFIG.WORLD_SIZE * 0.8);
                const z = (Math.random() - 0.5) * (CONFIG.WORLD_SIZE * 0.8);
                
                // Increased safe zone for larger cabin
                if (Math.abs(x - 80) < 80 && Math.abs(z + 60) < 80) continue;

                const h = getTerrainHeight(x, z);
                
                const scale = 5 + Math.random() * 5; 
                const trunkHeight = 10 * scale;

                // --- FIX: Tree Floating ---
                const sinkAmount = scale * 1.5; 

                const trunk = new THREE.Mesh(geomTrunk, trunkMat);
                
                trunk.position.set(x, h + (trunkHeight / 2) - sinkAmount, z);
                trunk.scale.set(scale, trunkHeight + sinkAmount, scale); 
                
                trunk.castShadow = true;
                trunk.receiveShadow = true;

                // Leaves
                const layers = 3 + Math.floor(Math.random() * 3); 
                for(let L=0; L<layers; L++) {
                    const widthRatio = 1 - (L / layers); 
                    const coneRadius = (4.5 * scale) * widthRatio;
                    const leaves = new THREE.Mesh(geomCone, leafMat);
                    
                    const parentYScale = trunk.scale.y; 
                    
                    leaves.scale.set(
                        coneRadius / scale, 
                        ((5 * scale) / parentYScale), 
                        coneRadius / scale
                    );
                    
                    leaves.position.y = 0.5 + (L * 0.15); 
                    leaves.castShadow = true;
                    trunk.add(leaves);
                }

                // Physics
                const boundary = new THREE.Mesh(new THREE.BoxGeometry(2*scale, trunkHeight, 2*scale));
                boundary.position.set(x, h + (trunkHeight/2), z); 
                boundary.visible = false;
                scene.add(boundary);
                collidableObjects.push(boundary);

                scene.add(trunk);
            }
        }

        function performPunch() {
            if(!controls.isLocked) return;
            const container = document.getElementById('weapon-container');
            container.classList.remove('punching');
            void container.offsetWidth; 
            container.classList.add('punching');
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            if (controls.isLocked) {
                // --- PHYSICS ---
                velocity.x -= velocity.x * 8.0 * delta;
                velocity.z -= velocity.z * 8.0 * delta;
                velocity.y -= CONFIG.GRAVITY * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = isSprinting ? CONFIG.SPRINT_SPEED : CONFIG.WALK_SPEED;

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                let playerPos = controls.getObject().position;

                // 1. Terrain Collision
                const groundHeight = getTerrainHeight(playerPos.x, playerPos.z);
                
                if (playerPos.y < groundHeight + CONFIG.PLAYER_HEIGHT) {
                    velocity.y = Math.max(0, velocity.y);
                    playerPos.y = groundHeight + CONFIG.PLAYER_HEIGHT;
                    canJump = true;
                }

                // 2. Object Collision
                playerBox.setFromCenterAndSize(playerPos, new THREE.Vector3(CONFIG.PLAYER_RADIUS*2, CONFIG.PLAYER_HEIGHT, CONFIG.PLAYER_RADIUS*2));

                for (const obj of collidableObjects) {
                    // Increased check distance for larger objects
                    if(Math.abs(playerPos.x - obj.position.x) > 60 || Math.abs(playerPos.z - obj.position.z) > 60) continue;

                    tempBox.setFromObject(obj);
                    if (playerBox.intersectsBox(tempBox)) {
                        const overlap = playerBox.clone().intersect(tempBox);
                        const size = new THREE.Vector3();
                        overlap.getSize(size);

                        // Favor pushing horizontally
                        if (size.y < size.x && size.y < size.z) {
                             // Push up/down (less likely in this setup but possible on edges)
                             const dir = playerPos.y > obj.position.y ? 1 : -1;
                             playerPos.y += (size.y + 0.1) * dir;
                             velocity.y = 0;
                        }
                        else if (size.x < size.z) {
                            const dir = playerPos.x > obj.position.x ? 1 : -1;
                            playerPos.x += (size.x + 0.1) * dir;
                            velocity.x = 0;
                        } else {
                            const dir = playerPos.z > obj.position.z ? 1 : -1;
                            playerPos.z += (size.z + 0.1) * dir;
                            velocity.z = 0;
                        }
                        playerBox.setFromCenterAndSize(playerPos, new THREE.Vector3(CONFIG.PLAYER_RADIUS*2, CONFIG.PLAYER_HEIGHT, CONFIG.PLAYER_RADIUS*2));
                    }
                }

                // --- VISUALS ---
                const isMoving = Math.abs(velocity.x) > 10 || Math.abs(velocity.z) > 10;
                let camBobY = 0;
                let camTiltZ = 0;
                const weapon = document.getElementById('weapon-container');

                if(isMoving && canJump) {
                    const freq = isSprinting ? CONFIG.BOB_SPEED * 1.5 : CONFIG.BOB_SPEED;
                    bobTimer += delta * freq;
                    camBobY = Math.sin(bobTimer) * (isSprinting ? 0.7 : 0.35);
                    const swayX = Math.cos(bobTimer) * 30; 
                    const swayY = Math.abs(Math.sin(bobTimer)) * 15;
                    weapon.style.transform = `translate(${swayX}px, ${swayY}px)`;
                    if(moveLeft) camTiltZ = 0.03;
                    else if(moveRight) camTiltZ = -0.03;
                } else {
                    bobTimer = 0;
                    weapon.style.transform = `translate(0px, 0px)`;
                    camTiltZ = 0; 
                }

                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, camTiltZ, delta * 8);

                const physicsY = playerPos.y;
                playerPos.y = physicsY + camBobY;

                renderer.render(scene, camera);

                playerPos.y = physicsY;
            } else {
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
